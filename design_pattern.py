# -*- coding: utf-8 -*-
"""Design Pattern.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RQJh8MAmH4QoqN-NPS4jARsLac0qiKUX
"""

# Creational Design Pattern
# Without Factory
class Car:
    def create(self):
        return "Car created!"

class Bike:
    def create(self):
        return "Bike created!"

# Client code creating specific objects directly
vehicle_type = "car"

if vehicle_type == "car":
    vehicle = Car()
elif vehicle_type == "bike":
    vehicle = Bike()
else:
    raise ValueError("Unknown vehicle type")

print(vehicle.create())  # Output: Car created!

# With Factory

from abc import ABC, abstractmethod

# Product interface
class Vehicle(ABC):
    @abstractmethod
    def create(self):
        pass

# Concrete Products
class Car(Vehicle):
    def create(self):
        return "Car created!"

class Bike(Vehicle):
    def create(self):
        return "Bike created!"

# Abstract Creator (Factory) class
class VehicleFactory(ABC):
    @abstractmethod
    def create_vehicle(self):
        pass

# Concrete Creator classes
class CarFactory(VehicleFactory):
    def create_vehicle(self):
        return Car()

class BikeFactory(VehicleFactory):
    def create_vehicle(self):
        return Bike()

# Client code
def get_vehicle(factory: VehicleFactory):
    vehicle = factory.create_vehicle()
    return vehicle.create()

# Using the Factory Method pattern
car_factory = CarFactory()
bike_factory = BikeFactory()

print(get_vehicle(car_factory))  # Output: Car created!
print(get_vehicle(bike_factory)) # Output: Bike created!

# Without Abstarct Factory

class ModernChair:
    def sit_on(self):
        return "Sitting on a modern chair"

class ModernTable:
    def use(self):
        return "Using a modern table"

class VictorianChair:
    def sit_on(self):
        return "Sitting on a Victorian chair"

class VictorianTable:
    def use(self):
        return "Using a Victorian table"

# Client code directly creating specific furniture families
furniture_type = "modern"

if furniture_type == "modern":
    chair = ModernChair()
    table = ModernTable()
elif furniture_type == "victorian":
    chair = VictorianChair()
    table = VictorianTable()
else:
    raise ValueError("Unknown furniture type")

print(chair.sit_on())  # Output: Sitting on a modern chair
print(table.use())     # Output: Using a modern table

# With Abstarct Factory

from abc import ABC, abstractmethod

# Abstract Product Interfaces
class Chair(ABC):
    @abstractmethod
    def sit_on(self):
        pass

class Table(ABC):
    @abstractmethod
    def use(self):
        pass

# Concrete Products for the Modern family
class ModernChair(Chair):
    def sit_on(self):
        return "Sitting on a modern chair"

class ModernTable(Table):
    def use(self):
        return "Using a modern table"

# Concrete Products for the Victorian family
class VictorianChair(Chair):
    def sit_on(self):
        return "Sitting on a Victorian chair"

class VictorianTable(Table):
    def use(self):
        return "Using a Victorian table"

# Abstract Factory Interface
class FurnitureFactory(ABC):
    @abstractmethod
    def create_chair(self) -> Chair:
        pass

    @abstractmethod
    def create_table(self) -> Table:
        pass

# Concrete Factories for each family
class ModernFurnitureFactory(FurnitureFactory):
    def create_chair(self) -> Chair:
        return ModernChair()

    def create_table(self) -> Table:
        return ModernTable()

class VictorianFurnitureFactory(FurnitureFactory):
    def create_chair(self) -> Chair:
        return VictorianChair()

    def create_table(self) -> Table:
        return VictorianTable()

# Client code
def create_furniture(factory: FurnitureFactory):
    chair = factory.create_chair()
    table = factory.create_table()
    print(chair.sit_on())
    print(table.use())

# Using the Abstract Factory pattern
modern_factory = ModernFurnitureFactory()
victorian_factory = VictorianFurnitureFactory()

print("Modern Furniture:")
create_furniture(modern_factory)
# Output:
# Sitting on a modern chair
# Using a modern table

print("\nVictorian Furniture:")
create_furniture(victorian_factory)
# Output:
# Sitting on a Victorian chair
# Using a Victorian table

# without Builder
class House:
    def __init__(self, walls, doors, windows, roof, garage, pool):
        self.walls = walls
        self.doors = doors
        self.windows = windows
        self.roof = roof
        self.garage = garage
        self.pool = pool

    def __str__(self):
        return (f"House with {self.walls} walls, {self.doors} doors, "
                f"{self.windows} windows, roof type {self.roof}, "
                f"{'with' if self.garage else 'without'} garage, "
                f"{'with' if self.pool else 'without'} pool")

# Building the house
house = House(walls=4, doors=2, windows=8, roof="Gable", garage=True, pool=False)
print(house)
# Output: House with 4 walls, 2 doors, 8 windows, roof type Gable, with garage, without pool

# with Builder
from abc import ABC, abstractmethod

# Product: House
class House:
    def __init__(self):
        self.walls = None
        self.doors = None
        self.windows = None
        self.roof = None
        self.garage = None
        self.pool = None

    def __str__(self):
        return (f"House with {self.walls} walls, {self.doors} doors, "
                f"{self.windows} windows, roof type {self.roof}, "
                f"{'with' if self.garage else 'without'} garage, "
                f"{'with' if self.pool else 'without'} pool")

# Builder Interface
class HouseBuilder(ABC):
    @abstractmethod
    def build_walls(self, walls): pass

    @abstractmethod
    def build_doors(self, doors): pass

    @abstractmethod
    def build_windows(self, windows): pass

    @abstractmethod
    def build_roof(self, roof): pass

    @abstractmethod
    def add_garage(self, has_garage): pass

    @abstractmethod
    def add_pool(self, has_pool): pass

    @abstractmethod
    def get_house(self) -> House: pass

# Concrete Builder
class ConcreteHouseBuilder(HouseBuilder):
    def __init__(self):
        self.house = House()

    def build_walls(self, walls):
        self.house.walls = walls

    def build_doors(self, doors):
        self.house.doors = doors

    def build_windows(self, windows):
        self.house.windows = windows

    def build_roof(self, roof):
        self.house.roof = roof

    def add_garage(self, has_garage):
        self.house.garage = has_garage

    def add_pool(self, has_pool):
        self.house.pool = has_pool

    def get_house(self) -> House:
        return self.house

# Director
class HouseDirector:
    def __init__(self, builder: HouseBuilder):
        self.builder = builder

    def construct_basic_house(self):
        self.builder.build_walls(4)
        self.builder.build_doors(1)
        self.builder.build_windows(4)
        self.builder.build_roof("Flat")
        self.builder.add_garage(False)
        self.builder.add_pool(False)
        return self.builder.get_house()

    def construct_luxury_house(self):
        self.builder.build_walls(6)
        self.builder.build_doors(3)
        self.builder.build_windows(10)
        self.builder.build_roof("Gable")
        self.builder.add_garage(True)
        self.builder.add_pool(True)
        return self.builder.get_house()

# Client Code
builder = ConcreteHouseBuilder()
director = HouseDirector(builder)

# Building a basic house
basic_house = director.construct_basic_house()
print(basic_house)
# Output: House with 4 walls, 1 doors, 4 windows, roof type Flat, without garage, without pool

# Building a luxury house
luxury_house = director.construct_luxury_house()
print(luxury_house)
# Output: House with 6 walls, 3 doors, 10 windows, roof type Gable, with garage, with pool

# without Prototype
class Shape:
    def __init__(self, color, size):
        self.color = color
        self.size = size

    def __str__(self):
        return f"Shape with color {self.color} and size {self.size}"

# Creating objects individually
circle1 = Shape("red", "large")
circle2 = Shape("red", "large")

# Checking if they are distinct instances
print(circle1)  # Output: Shape with color red and size large
print(circle2)  # Output: Shape with color red and size large
print(circle1 is circle2)  # Output: False

# with Prototype

import copy
from abc import ABC, abstractmethod

# Prototype Interface
class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

# Concrete Prototype
class Shape(Prototype):
    def __init__(self, color, size):
        self.color = color
        self.size = size

    def clone(self):
        # Perform a deep copy of the current instance
        return copy.deepcopy(self)

    def __str__(self):
        return f"Shape with color {self.color} and size {self.size}"

# Client Code
# Creating an original instance
circle1 = Shape("red", "large")

# Cloning the original instance to create a duplicate
circle2 = circle1.clone()

# Modifying the clone's properties to show independence if needed
circle2.color = "blue"

print(circle1)  # Output: Shape with color red and size large
print(circle2)  # Output: Shape with color blue and size large
print(circle1 is circle2)  # Output: False

# Without Singleton
class DatabaseConnection:
    def __init__(self):
        self.connection = self.connect()

    def connect(self):
        # Placeholder for actual connection code
        return "Database connection established"

# Creating multiple instances of DatabaseConnection
db1 = DatabaseConnection()
db2 = DatabaseConnection()

# Checking if both instances are the same
print(db1.connection)  # Output: Database connection established
print(db2.connection)  # Output: Database connection established
print(db1 is db2)      # Output: False

# With Singleton
class SingletonDatabaseConnection:
    _instance = None  # Private class attribute to hold the single instance

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SingletonDatabaseConnection, cls).__new__(cls)
            cls._instance.connection = cls._instance.connect()
        return cls._instance

    def connect(self):
        # Placeholder for actual connection code
        return "Singleton Database connection established"

# Using Singleton pattern to get the instance
db1 = SingletonDatabaseConnection()
db2 = SingletonDatabaseConnection()

# Checking if both instances are the same
print(db1.connection)  # Output: Singleton Database connection established
print(db2.connection)  # Output: Singleton Database connection established
print(db1 is db2)      # Output: True

# Structural Design Pattern
# without Adapter

# Incompatible interface
class EuropeanSocket:
    def provide_power_220v(self):
        return "220V power from European socket"

# Client code expecting a different interface
class Device:
    def power_on(self, power_source):
        if power_source == "110V power from USA socket":
            return "Device powered on"
        else:
            return "Incompatible power source"

# Direct usage without adapter
european_socket = EuropeanSocket()
device = Device()

# Client code has to manually handle the compatibility issue
power = european_socket.provide_power_220v()
print(device.power_on(power))  # Output: Incompatible power source

# with Adapter

# Target interface
class USASocket:
    def provide_power_110v(self):
        pass

# Incompatible interface (Adaptee)
class EuropeanSocket:
    def provide_power_220v(self):
        return "220V power from European socket"

# Adapter class to adapt EuropeanSocket to USASocket interface
class SocketAdapter(USASocket):
    def __init__(self, european_socket):
        self.european_socket = european_socket

    def provide_power_110v(self):
        # Adapting 220V to 110V power
        power = self.european_socket.provide_power_220v()
        return power.replace("220V", "110V")  # Simulating voltage conversion

# Client code
class Device:
    def power_on(self, power_source):
        if power_source == "110V power from European socket":
            return "Device powered on"
        else:
            return "Incompatible power source"

# Using the Adapter to connect incompatible interfaces
european_socket = EuropeanSocket()
adapter = SocketAdapter(european_socket)  # Wrapping the adaptee in an adapter
device = Device()

# Now client code can use the adapter to power on the device
power = adapter.provide_power_110v()
print(device.power_on(power))  # Output: Device powered on

# without Bridge Pattern
# Without Bridge - Proliferation of subclasses

class TVBasicRemote:
    def power(self):
        return "TV turned on/off"

    def volume_up(self):
        return "TV volume up"

    def volume_down(self):
        return "TV volume down"

class TVAdvancedRemote:
    def power(self):
        return "TV turned on/off"

    def volume_up(self):
        return "TV volume up"

    def volume_down(self):
        return "TV volume down"

    def mute(self):
        return "TV muted"

class RadioBasicRemote:
    def power(self):
        return "Radio turned on/off"

    def volume_up(self):
        return "Radio volume up"

    def volume_down(self):
        return "Radio volume down"

class RadioAdvancedRemote:
    def power(self):
        return "Radio turned on/off"

    def volume_up(self):
        return "Radio volume up"

    def volume_down(self):
        return "Radio volume down"

    def mute(self):
        return "Radio muted"

# Client code for each remote variant
tv_basic_remote = TVBasicRemote()
print(tv_basic_remote.power())        # Output: TV turned on/off
print(tv_basic_remote.volume_up())    # Output: TV volume up

radio_advanced_remote = RadioAdvancedRemote()
print(radio_advanced_remote.power())  # Output: Radio turned on/off
print(radio_advanced_remote.mute())   # Output: Radio muted

# with Bridge Pattern
from abc import ABC, abstractmethod

# Implementation Interface
class Device(ABC):
    @abstractmethod
    def power(self):
        pass

    @abstractmethod
    def volume_up(self):
        pass

    @abstractmethod
    def volume_down(self):
        pass

# Concrete Implementations
class TV(Device):
    def power(self):
        return "TV turned on/off"

    def volume_up(self):
        return "TV volume up"

    def volume_down(self):
        return "TV volume down"

class Radio(Device):
    def power(self):
        return "Radio turned on/off"

    def volume_up(self):
        return "Radio volume up"

    def volume_down(self):
        return "Radio volume down"

# Abstraction
class RemoteControl:
    def __init__(self, device: Device):
        self.device = device

    def power(self):
        return self.device.power()

    def volume_up(self):
        return self.device.volume_up()

    def volume_down(self):
        return self.device.volume_down()

# Refined Abstraction: Basic Remote
class BasicRemote(RemoteControl):
    pass

# Refined Abstraction: Advanced Remote
class AdvancedRemote(RemoteControl):
    def mute(self):
        return f"{self.device.__class__.__name__} muted"

# Client code using the Bridge Pattern
tv = TV()
basic_remote = BasicRemote(tv)
print(basic_remote.power())         # Output: TV turned on/off
print(basic_remote.volume_up())     # Output: TV volume up

radio = Radio()
advanced_remote = AdvancedRemote(radio)
print(advanced_remote.power())      # Output: Radio turned on/off
print(advanced_remote.mute())       # Output: Radio muted

# without Facade Pattern
# Subsystem classes
class CPU:
    def freeze(self):
        return "CPU: freeze"

    def jump(self, position):
        return f"CPU: jump to {position}"

    def execute(self):
        return "CPU: execute"

class Memory:
    def load(self, position, data):
        return f"Memory: load data at {position}"

class HardDrive:
    def read(self, lba, size):
        return f"HardDrive: read {size} bytes at {lba}"

# Client code - interacts with each subsystem directly
cpu = CPU()
memory = Memory()
hard_drive = HardDrive()

# Starting the computer requires interacting with each subsystem separately
print(cpu.freeze())                        # Output: CPU: freeze
print(memory.load("0x00", "boot_data"))    # Output: Memory: load data at 0x00
print(cpu.jump("0x00"))                    # Output: CPU: jump to 0x00
print(hard_drive.read("0x00", 4096))       # Output: HardDrive: read 4096 bytes at 0x00
print(cpu.execute())                       # Output: CPU: execute

# with Facade Pattern
# Subsystem classes
class CPU:
    def freeze(self):
        return "CPU: freeze"

    def jump(self, position):
        return f"CPU: jump to {position}"

    def execute(self):
        return "CPU: execute"

class Memory:
    def load(self, position, data):
        return f"Memory: load data at {position}"

class HardDrive:
    def read(self, lba, size):
        return f"HardDrive: read {size} bytes at {lba}"

# Facade class
class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hard_drive = HardDrive()

    def start_computer(self):
        steps = [
            self.cpu.freeze(),
            self.memory.load("0x00", "boot_data"),
            self.cpu.jump("0x00"),
            self.hard_drive.read("0x00", 4096),
            self.cpu.execute()
        ]
        return "\n".join(steps)

# Client code using the Facade
computer = ComputerFacade()
print(computer.start_computer())
# Output:
# CPU: freeze
# Memory: load data at 0x00
# CPU: jump to 0x00
# HardDrive: read 4096 bytes at 0x00
# CPU: execute

# without DECORATORS Pattern
# Base component
class Coffee:
    def cost(self):
        return 5

    def description(self):
        return "Basic Coffee"

# Extended functionality by subclassing
class MilkCoffee(Coffee):
    def cost(self):
        return super().cost() + 2

    def description(self):
        return super().description() + " + Milk"

class SugarCoffee(Coffee):
    def cost(self):
        return super().cost() + 1

    def description(self):
        return super().description() + " + Sugar"

class MilkSugarCoffee(Coffee):
    def cost(self):
        return super().cost() + 3

    def description(self):
        return super().description() + " + Milk + Sugar"

# Client code
basic_coffee = Coffee()
print(basic_coffee.description())  # Output: Basic Coffee
print(basic_coffee.cost())         # Output: 5

milk_coffee = MilkCoffee()
print(milk_coffee.description())   # Output: Basic Coffee + Milk
print(milk_coffee.cost())          # Output: 7

milk_sugar_coffee = MilkSugarCoffee()
print(milk_sugar_coffee.description())  # Output: Basic Coffee + Milk + Sugar
print(milk_sugar_coffee.cost())         # Output: 8

# with DECORATORS  Pattern

from abc import ABC, abstractmethod

# Component interface
class Coffee(ABC):
    @abstractmethod
    def cost(self):
        pass

    @abstractmethod
    def description(self):
        pass

# Concrete component
class BasicCoffee(Coffee):
    def cost(self):
        return 5

    def description(self):
        return "Basic Coffee"

# Decorator base class
class CoffeeDecorator(Coffee):
    def __init__(self, coffee):
        self._coffee = coffee

    def cost(self):
        return self._coffee.cost()

    def description(self):
        return self._coffee.description()

# Concrete decorators
class MilkDecorator(CoffeeDecorator):
    def cost(self):
        return super().cost() + 2

    def description(self):
        return super().description() + " + Milk"

class SugarDecorator(CoffeeDecorator):
    def cost(self):
        return super().cost() + 1

    def description(self):
        return super().description() + " + Sugar"

# Client code using decorators
basic_coffee = BasicCoffee()
print(basic_coffee.description())  # Output: Basic Coffee
print(basic_coffee.cost())         # Output: 5

# Adding Milk to Basic Coffee
milk_coffee = MilkDecorator(basic_coffee)
print(milk_coffee.description())   # Output: Basic Coffee + Milk
print(milk_coffee.cost())          # Output: 7

# Adding both Milk and Sugar to Basic Coffee
milk_sugar_coffee = SugarDecorator(milk_coffee)
print(milk_sugar_coffee.description())  # Output: Basic Coffee + Milk + Sugar
print(milk_sugar_coffee.cost())         # Output: 8

# without Proxy Pattern

# with Proxy Pattern

# Behavioral

# without Observer

# Stock class which directly updates displays

class Stock:
    def __init__(self, name, price):
        self.name = name
        self.price = price
        self.display_a = StockDisplayA()
        self.display_b = StockDisplayB()

    def set_price(self, price):
        self.price = price
        self.update_displays()

    def update_displays(self):
        # Manually calling update methods for each display
        self.display_a.update(self)
        self.display_b.update(self)

class StockDisplayA:
    def update(self, stock):
        print(f"[Display A] {stock.name} price updated to {stock.price}")

class StockDisplayB:
    def update(self, stock):
        print(f"[Display B] {stock.name} price updated to {stock.price}")

# Client code
stock = Stock("AAPL", 150)
stock.set_price(155)  # Must call set_price explicitly, tightly coupled to displays

# with Observer
from abc import ABC, abstractmethod

# Observer Interface
class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

# Concrete Observers
class StockDisplayA(Observer):
    def update(self, subject):
        print(f"[Display A] {subject.name} price updated to {subject.price}")

class StockDisplayB(Observer):
    def update(self, subject):
        print(f"[Display B] {subject.name} price updated to {subject.price}")

# Subject Class
class Stock:
    def __init__(self, name, price):
        self.name = name
        self.price = price
        self.observers = []

    def add_observer(self, observer):
        self.observers.append(observer)

    def remove_observer(self, observer):
        self.observers.remove(observer)

    def set_price(self, price):
        self.price = price
        self.notify_observers()

    def notify_observers(self):
        # Notify each observer of the update
        for observer in self.observers:
            observer.update(self)

# Client code
stock = Stock("AAPL", 150)
display_a = StockDisplayA()
display_b = StockDisplayB()

# Register observers with the stock subject
stock.add_observer(display_a)
stock.add_observer(display_b)

# Update the stock price, notifying observers automatically
stock.set_price(155)
# Output:
# [Display A] AAPL price updated to 155
# [Display B] AAPL price updated to 155

# without stradegy

# PaymentProcessor class with conditional statements for each payment method

class PaymentProcessor:
    def process_payment(self, amount, method):
        if method == "credit_card":
            print(f"Processing credit card payment of {amount}")
        elif method == "paypal":
            print(f"Processing PayPal payment of {amount}")
        else:
            raise ValueError("Unsupported payment method")

# Client code
processor = PaymentProcessor()
processor.process_payment(100, "credit_card")  # Processing credit card payment of 100
processor.process_payment(50, "paypal")        # Processing PayPal payment of 50

# without stradegy

from abc import ABC, abstractmethod

# Strategy Interface
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

# Concrete Strategy for Credit Card payment
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount):
        print(f"Processing credit card payment of {amount}")

# Concrete Strategy for PayPal payment
class PayPalPayment(PaymentStrategy):
    def pay(self, amount):
        print(f"Processing PayPal payment of {amount}")

# Context class
class PaymentProcessor:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy

    def set_strategy(self, strategy: PaymentStrategy):
        self._strategy = strategy

    def process_payment(self, amount):
        self._strategy.pay(amount)

# Client code
# Use Credit Card payment
credit_card_strategy = CreditCardPayment()
processor = PaymentProcessor(credit_card_strategy)
processor.process_payment(100)  # Output: Processing credit card payment of 100

# Switch to PayPal payment
paypal_strategy = PayPalPayment()
processor.set_strategy(paypal_strategy)
processor.process_payment(50)  # Output: Processing PayPal payment of 50

# without state

# Document class with conditional statements for each state

class Document:
    def __init__(self):
        self.state = "Draft"

    def publish(self):
        if self.state == "Draft":
            self.state = "Moderation"
            print("Document is sent to moderation.")
        elif self.state == "Moderation":
            self.state = "Published"
            print("Document is published.")
        elif self.state == "Published":
            print("Document is already published.")

    def edit(self):
        if self.state == "Draft":
            print("Editing the document...")
        elif self.state in ["Moderation", "Published"]:
            print("Cannot edit. Document is not in Draft state.")

# Client code
doc = Document()
doc.edit()      # Output: Editing the document...
doc.publish()   # Output: Document is sent to moderation.
doc.edit()      # Output: Cannot edit. Document is not in Draft state.
doc.publish()   # Output: Document is published.
doc.publish()   # Output: Document is already published.

# with state

from abc import ABC, abstractmethod

# State Interface
class State(ABC):
    @abstractmethod
    def publish(self, document):
        pass

    @abstractmethod
    def edit(self, document):
        pass

# Concrete State for Draft
class DraftState(State):
    def publish(self, document):
        document.set_state(ModerationState())
        print("Document is sent to moderation.")

    def edit(self, document):
        print("Editing the document...")

# Concrete State for Moderation
class ModerationState(State):
    def publish(self, document):
        document.set_state(PublishedState())
        print("Document is published.")

    def edit(self, document):
        print("Cannot edit. Document is in moderation.")

# Concrete State for Published
class PublishedState(State):
    def publish(self, document):
        print("Document is already published.")

    def edit(self, document):
        print("Cannot edit. Document is already published.")

# Context class
class Document:
    def __init__(self):
        self._state = DraftState()  # Start in the Draft state

    def set_state(self, state: State):
        self._state = state

    def publish(self):
        self._state.publish(self)

    def edit(self):
        self._state.edit(self)

# Client code
doc = Document()
doc.edit()      # Output: Editing the document...
doc.publish()   # Output: Document is sent to moderation.
doc.edit()      # Output: Cannot edit. Document is in moderation.
doc.publish()   # Output: Document is published.
doc.publish()   # Output: Document is already published.

# without meditater

# Chat Users communicating directly with each other

class User:
    def __init__(self, name):
        self.name = name
        self.contacts = []  # List of users to communicate with

    def add_contact(self, user):
        self.contacts.append(user)

    def send_message(self, message):
        for contact in self.contacts:
            contact.receive_message(message, self.name)

    def receive_message(self, message, sender_name):
        print(f"{self.name} received message from {sender_name}: {message}")

# Client code
user1 = User("User1")
user2 = User("User2")
user3 = User("User3")

# Manually adding contacts
user1.add_contact(user2)
user2.add_contact(user1)
user2.add_contact(user3)
user3.add_contact(user2)

# Sending messages directly between users
user1.send_message("Hello from User1!")
user2.send_message("Hello from User2!")
user3.send_message("Hello from User3!")

# with meditater

from abc import ABC, abstractmethod

# Mediator Interface
class ChatMediator(ABC):
    @abstractmethod
    def show_message(self, user, message):
        pass

# Concrete Mediator
class ChatRoomMediator(ChatMediator):
    def show_message(self, user, message):
        print(f"[{user.name}] says: {message}")

# Colleague (User) Class
class User:
    def __init__(self, name, mediator: ChatMediator):
        self.name = name
        self.mediator = mediator

    def send_message(self, message):
        self.mediator.show_message(self, message)

# Client code
mediator = ChatRoomMediator()

user1 = User("User1", mediator)
user2 = User("User2", mediator)
user3 = User("User3", mediator)

# Sending messages through mediator
user1.send_message("Hello from User1!")  # Output: [User1] says: Hello from User1!
user2.send_message("Hello from User2!")  # Output: [User2] says: Hello from User2!
user3.send_message("Hello from User3!")  # Output: [User3] says: Hello from User3!

# without tempalte

# Data processors without using the Template pattern

class JSONProcessor:
    def load_data(self):
        print("Loading JSON data...")

    def process_data(self):
        print("Processing JSON data...")

    def save_data(self):
        print("Saving JSON data...")

    def execute(self):
        self.load_data()
        self.process_data()
        self.save_data()


class XMLProcessor:
    def load_data(self):
        print("Loading XML data...")

    def process_data(self):
        print("Processing XML data...")

    def save_data(self):
        print("Saving XML data...")

    def execute(self):
        self.load_data()
        self.process_data()
        self.save_data()


# Client code
json_processor = JSONProcessor()
json_processor.execute()
# Output:
# Loading JSON data...
# Processing JSON data...
# Saving JSON data...

xml_processor = XMLProcessor()
xml_processor.execute()
# Output:
# Loading XML data...
# Processing XML data...
# Saving XML data...

# with tempalte

from abc import ABC, abstractmethod

# Abstract Class
class DataProcessor(ABC):
    def execute(self):
        self.load_data()
        self.process_data()
        self.save_data()

    def load_data(self):
        print("Loading data...")  # Common implementation; subclasses can override

    @abstractmethod
    def process_data(self):
        pass

    def save_data(self):
        print("Saving data...")  # Common implementation; subclasses can override if needed

# Concrete Class for JSON Processing
class JSONProcessor(DataProcessor):
    def process_data(self):
        print("Processing JSON data...")

# Concrete Class for XML Processing
class XMLProcessor(DataProcessor):
    def process_data(self):
        print("Processing XML data...")

# Client code
json_processor = JSONProcessor()
json_processor.execute()
# Output:
# Loading data...
# Processing JSON data...
# Saving data...

xml_processor = XMLProcessor()
xml_processor.execute()
# Output:
# Loading data...
# Processing XML data...
# Saving data...





list = [1,2,3,4,5]
list = enumerate(list)
x = next(list)
print(x)
x = next(list)
print(x)

from abc import ABC, abstractmethod

# Product
class IShape(ABC):
    @abstractmethod
    def calculate_area(self):
        pass

    @abstractmethod
    def calculate_perimeter(self):
        pass

# Concrete Product
class Rectangle(IShape):
    def __init__(self, height, width):
        self.height = height
        self.width = width

    def calculate_area(self):
        return self.height * self.width

    def calculate_perimeter(self):
        return 2 * (self.height + self.width)

class Square(IShape):
    def __init__(self, width):
        self.width = width

    def calculate_area(self):
        return self.width ** 2

    def calculate_perimeter(self):
        return 4 * self.width

class Circle(IShape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius * self.radius

    def calculate_perimeter(self):
        return 2 * 3.14 * self.radius

# Creator
class IShapeFactory(ABC):
       #Factory method
       @abstractmethod
       def create_shape(self, name):
           pass


class CircleFactory(IShapeFactory):

    def create_shape(self, name):
            radius = input("Enter the radius of the circle: ")
            return Circle(float(radius))

class RectangleFactory(IShapeFactory):

        def create_shape(self, name):
            height = input("Enter the height of the rectangle: ")
            width = input("Enter the width of the rectangle: ")
            return Rectangle(int(height), int(width))

class SquareFactory(IShapeFactory):

        def create_shape(self, name):
            width = input("Enter the width of the square: ")
            return Square(int(width))

# Client Code

def shapes_client():
    shape_factory = ShapeFactory()

    shape_name = input("Enter the name of the shape: ")


    if (shape_name == "circle"):
        shape_factory = CircleFactory()
    elif (shape_name == "rectangle"):
        shape_factory = RectangleFactory()
    elif (shape_name == "square"):
        shape_factory = SquareFactory()
    else:
        print("Invalid shape name")
        return

    shape = shape_factory.create_shape(shape_name)

    print(f"The type of object created: {type(shape)}")
    print(f"The area of the {shape_name} is: {shape.calculate_area()}")
    print(f"The perimeter of the {shape_name} is: {shape.calculate_perimeter()}")

if __name__ == "__main__":
    shapes_client()

from abc import ABC, abstractmethod

# abstract products - Browser and Messenger

class Browser(ABC):
    """
    Creates "Abstract Product A"
    """

    # Interface - Create Search Toolbar
    @abstractmethod
    def create_search_toolbar(self):
        pass

    # Interface - Create Browser Window
    @abstractmethod
    def create_browser_window(self):
        pass

class Messenger(ABC):
    """
    Creates "Abstract Product B"
    """

    @abstractmethod
    # Interface - Create Messenger Window
    def create_messenger_window(self):
        pass


# Concrete Product VanillaBrowser, VanillaMessenger
class VanillaBrowser(Browser):
    """
    Type: Concrete Product
    Abstract methods of the Browser base class are implemented.
    """

    # Interface - Create Search Toolbar
    def create_search_toolbar(self):
        print("Search Toolbar Created")

    # Interface - Create Browser Window]
    def create_browser_window(self):
        print("Browser Window Created")


class VanillaMessenger(Messenger):
    """
    Type: Concrete Product
    Abstract methods of the Messenger base class are implemented.
    """

    # Interface - Create Messenger Window
    def create_messenger_window(self):
        print("Messenger Window Created")

class SecureBrowser(Browser):
    """
    Type: Concrete Product
    Abstract methods of the Browser base class are implemented.
    """

    # Abstract Method of the Browser base class
    def create_search_toolbar(self):
        print("Secure Browser - Search Toolbar Created")

    # Abstract Method of the Browser base class
    def create_browser_window(self):
        print("Secure Browser - Browser Window Created")

    def create_incognito_mode(self):
        print("Secure Browser - Incognito Mode Created")


class SecureMessenger(Messenger):
    """
    Type: Concrete Product
    Abstract methods of the Messenger base class are implemented.
    """

    # Abstract Method of the Messenger base class
    def create_messenger_window(self):
        print("Secure Messenger - Messenger Window Created")

    def create_privacy_filter(self):
        print("Secure Messenger - Privacy Filter Created")

    def disappearing_messages(self):
        print("Secure Messenger - Disappearing Messages Feature Enabled")


# Abstract Factory
class AbstractFactory(ABC):
    """
    The Abstract Factory
    """

    @abstractmethod
    def create_browser(self):
        pass

    @abstractmethod
    def create_messenger(self):
        pass

# Concrete Factory VanillaProductsFactory, SecureProductsFactory
class VanillaProductsFactory(AbstractFactory):
    """
    Type: Concrete Factory
    Implement the operations to create concrete product objects.
    """

    def create_browser(self):
        return VanillaBrowser()

    def create_messenger(self):
        return VanillaMessenger()

class SecureProductsFactory(AbstractFactory):
    """
    Type: Concrete Factory
    Implement the operations to create concrete product objects.
    """

    def create_browser(self):
        return SecureBrowser()

    def create_messenger(self):
        return SecureMessenger()

def main():
    for factory in (VanillaProductsFactory(), SecureProductsFactory()):
        product_a = factory.create_browser()
        product_b = factory.create_messenger()
        product_a.create_browser_window()
        product_a.create_search_toolbar()
        product_b.create_messenger_window()

if __name__ == "__main__":
    main()

Class Student:

def __init__(self, name, roll_number,course_id, marks, ):
self.name = name
self.roll_number = roll_number

#Builder Pattern
# Product
class Robot:
    def __init__(self):
        self.bipedal = False
        self.quadripedal = False
        self.wheeled = False
        self.flying = False
        self.traversal = []
        self.detection_systems = []

    def __str__(self):
        string = ""
        if self.bipedal:
            string += "BIPEDAL "
        if self.quadripedal:
            string += "QUADRIPEDAL "
        if self.flying:
            string += "FLYING ROBOT "
        if self.wheeled:
            string += "ROBOT ON WHEELS\n"
        else:
            string += "ROBOT\n"

        if self.traversal:
            string += "Traversal modules installed:\n"

        for module in self.traversal:
            string += "- " + str(module) + "\n"

        if self.detection_systems:
            string += "Detection systems installed:\n"

        for system in self.detection_systems:
            string += "- " + str(system) + "\n"

        return string

class BipedalLegs:
    def __str__(self):
        return "two legs"

class QuadripedalLegs:
    def __str__(self):
        return "four legs"

class Arms:
    def __str__(self):
        return "four legs"

class Wings:
    def __str__(self):
        return "wings"

class Blades:
    def __str__(self):
        return "blades"

class FourWheels:
    def __str__(self):
        return "four wheels"

class TwoWheels:
    def __str__(self):
        return "two wheels"

class CameraDetectionSystem:
    def __str__(self):
        return "cameras"

class InfraredDetectionSystem:
    def __str__(self):
        return "infrared"

# abstract Builder
from abc import ABC, abstractmethod

class RobotBuilder(ABC):

    @abstractmethod
    def reset(self):
        pass

    @abstractmethod
    def build_traversal(self):
        pass

    @abstractmethod
    def build_detection_system(self):
        pass

# Concrete Builders
# Builder class that constructs our object and adds appropriate modules
class AndroidBuilder(RobotBuilder):
    def __init__(self):
        self.product = Robot()

    def reset(self):
        self.product = Robot()

    def get_product(self):
        return self.product

    def build_traversal(self):
        self.product.bipedal = True
        self.product.traversal.append(BipedalLegs())
        self.product.traversal.append(Arms())

    def build_detection_system(self):
        self.product.detection_systems.append(CameraDetectionSystem())

class AutonomousCarBuilder(RobotBuilder):
    def __init__(self):
        self.product = Robot()

    def reset(self):
        self.product = Robot()

    def get_product(self):
        return self.product

    def build_traversal(self):
        self.product.wheeled = True
        self.product.traversal.append(FourWheels())

    def build_detection_system(self):
        self.product.detection_systems.append(InfraredDetectionSystem())

#Director
class Director:
    def make_android(self, builder):
        builder.build_traversal()
        builder.build_detection_system()
        return builder.get_product()

    def make_autonomous_car(self, builder):
        builder.build_traversal()
        builder.build_detection_system()
        return builder.get_product()


#Client Code 3
director = Director()
builder = AndroidBuilder()
print(director.make_android(builder))

builder = AutonomousCarBuilder()
print(director.make_autonomous_car(builder))

############# without director ################

#Client Code 1
builder = AndroidBuilder()
builder.build_traversal()
builder.build_detection_system()
print(builder.get_product())

#Client Code 2
builder = AutonomousCarBuilder()
builder.build_traversal()
builder.build_detection_system()
print(builder.get_product())

# Prototype  Pattern
from abc import ABC, abstractmethod
class Prototype(ABC):
    def clone(self):
        pass
class MyObject(Prototype):
    def __init__(self, arg1, arg2):
        self.field1 = arg1
        self.field2 = arg2

    def __operation__(self):
        self.performed_operation = True

    def clone(self):
        obj = MyObject(self.field1, field2)
        obj.performed_operation = self.performed_operation
        return obj

from abc import ABC, abstractmethod
import copy

class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass
class EnemyPrototype(Prototype):
    def __init__(self, name, health, attack_power):
        self.name = name
        self.health = health
        self.attack_power = attack_power

    def clone(self):
        return copy.deepcopy(self)

    def __str__(self):
        return f"Enemy(name={self.name}, health={self.health}, attack_power={self.attack_power})"

def client_code(prototype: Prototype):
    prototype_clone = prototype.clone()
    print("Cloned enemy:", prototype_clone)
    # Customizing the cloned enemy
    prototype_clone.health += 10
    prototype_clone.attack_power += 5
    print("Customized cloned enemy:", prototype_clone)

if __name__ == "__main__":
    # Creating a prototype for a basic enemy
    basic_enemy_prototype = EnemyPrototype("Goblin", 100, 15)
    print("Original enemy:", basic_enemy_prototype)

    # Using the prototype to create and customize new enemies
    client_code(basic_enemy_prototype)

class Singleton:
    _instance = None  # Class-level attribute to store the single instance

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)  # super() function retrieves the parent class
        return cls._instance
singleton1 = Singleton()
singleton2 = Singleton()

print(singleton1 is singleton2)

# Structural Pattern
# Adapter


class OldLogger:
    def log_message(self, message):
        print(f"Old logger: {message}")

class NewLogger:
    def log(self, severity, message):
        print(f"[{severity}] - {message}")

class LoggerAdapter:
    def __init__(self, new_logger):
        self.new_logger = new_logger

    def log_message(self, message):
        self.new_logger.log("INFO", message)

def client_code(logger):
    logger.log_message("This is a log message.")

# Client
# Using the old logger
old_logger = OldLogger()
client_code(old_logger)

# Using the new logger with an adapter
new_logger = NewLogger()
adapted_logger = LoggerAdapter(new_logger)
client_code(adapted_logger)

# Structural Pattern
# Adapter


class MotorCycle:
    """Class for MotorCycle"""

    def __init__(self):
        self.name = "MotorCycle"

    def TwoWheeler(self):
        return "TwoWheeler"


class Truck:
    """Class for Truck"""

    def __init__(self):
        self.name = "Truck"

    def EightWheeler(self):
        return "EightWheeler"


class Car:
    """Class for Car"""

    def __init__(self):
        self.name = "Car"

    def FourWheeler(self):
        return "FourWheeler"


class Adapter:
    """
    Adapts an object by replacing methods.
    Usage:
    motorCycle = MotorCycle()
    motorCycle = Adapter(motorCycle, wheels = motorCycle.TwoWheeler)
    """

    def __init__(self, obj, **adapted_methods):
        """We set the adapted methods in the object's dict"""
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        """All non-adapted calls are passed to the object"""
        return getattr(self.obj, attr)

    def original_dict(self):
        """Print original object dict"""
        return self.obj.__dict__


""" main method """
if __name__ == "__main__":

    """list to store objects"""
    objects = []

    motorCycle = MotorCycle()
    objects.append(Adapter(motorCycle, wheels=motorCycle.TwoWheeler))

    truck = Truck()
    objects.append(Adapter(truck, wheels=truck.EightWheeler))

    car = Car()
    objects.append(Adapter(car, wheels=car.FourWheeler))

    for obj in objects:
        print("A {0} is a {1} vehicle".format(obj.name, obj.wheels()))

# Structural Pattern
# Bridge

# Renderer interface
class Renderer:
    def render_circle(self, radius):
        raise NotImplementedError

    def render_square(self, side_length):
        raise NotImplementedError

# Vector rendering implementation
class VectorRenderer(Renderer):
    def render_circle(self, radius):
        print(f"Drawing a circle of radius {radius} with vector graphics.")

    def render_square(self, side_length):
        print(f"Drawing a square of side {side_length} with vector graphics.")

# Raster rendering implementation
class RasterRenderer(Renderer):
    def render_circle(self, radius):
        print(f"Drawing pixels for a circle of radius {radius}.")

    def render_square(self, side_length):
        print(f"Drawing pixels for a square of side {side_length}.")

# Shape abstraction class
class Shape:
    def __init__(self, renderer: Renderer):
        self.renderer = renderer

    def draw(self):
        raise NotImplementedError

    def scale(self, factor):
        raise NotImplementedError

# Circle shape (Refined Abstraction)
class Circle(Shape):
    def __init__(self, renderer: Renderer, radius):
        super().__init__(renderer)
        self.radius = radius

    def draw(self):
        self.renderer.render_circle(self.radius)

    def scale(self, factor):
        self.radius *= factor

# Square shape (Refined Abstraction)
class Square(Shape):
    def __init__(self, renderer: Renderer, side_length):
        super().__init__(renderer)
        self.side_length = side_length

    def draw(self):
        self.renderer.render_square(self.side_length)

    def scale(self, factor):
        self.side_length *= factor

# Client code
if __name__ == "__main__":
    # Using vector renderer for shapes
    vector_renderer = VectorRenderer()
    circle = Circle(vector_renderer, 5)
    square = Square(vector_renderer, 4)

    circle.draw()
    square.draw()

    # Scaling the shapes
    circle.scale(2)
    circle.draw()

    # Using raster renderer for shapes
    raster_renderer = RasterRenderer()
    big_circle = Circle(raster_renderer, 5)

    big_circle.draw()
    big_circle.scale(2)
    big_circle.draw()

# Basic coffee interface (Component)
class Coffee:
    def cost(self):
        raise NotImplementedError

    def description(self):
        raise NotImplementedError

# Plain coffee implementation (ConcreteComponent)
class PlainCoffee(Coffee):
    def cost(self):
        return 5  # base cost of plain coffee

    def description(self):
        return "Plain Coffee"

# Abstract decorator class (Decorator)
class CoffeeDecorator(Coffee):
    def __init__(self, coffee):
        self._coffee = coffee

    def cost(self):
        return self._coffee.cost()

    def description(self):
        return self._coffee.description()

# Concrete decorators that extend functionality (ConcreteDecorators)

class MilkDecorator(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 1  # Adding milk costs $1 more

    def description(self):
        return self._coffee.description() + ", Milk"

class SugarDecorator(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 0.5  # Adding sugar costs $0.50 more

    def description(self):
        return self._coffee.description() + ", Sugar"

class VanillaDecorator(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 2  # Adding vanilla costs $2 more

    def description(self):
        return self._coffee.description() + ", Vanilla"


# Client code
if __name__ == "__main__":
    # Start with a plain coffee
    my_coffee = PlainCoffee()
    print(f"{my_coffee.description()} costs ${my_coffee.cost()}")

    # Add milk
    my_coffee = MilkDecorator(my_coffee)
    print(f"{my_coffee.description()} costs ${my_coffee.cost()}")

    # Add sugar
    my_coffee = SugarDecorator(my_coffee)
    print(f"{my_coffee.description()} costs ${my_coffee.cost()}")

    # Add vanilla
    my_coffee = VanillaDecorator(my_coffee)
    print(f"{my_coffee.description()} costs ${my_coffee.cost()}")

# Facade Pattern

class TV:
    def on(self):
        print("TV is now ON.")

    def off(self):
        print("TV is now OFF.")

class DVDPlayer:
    def on(self):
        print("DVD Player is now ON.")

    def off(self):
        print("DVD Player is now OFF.")

    def play(self, movie):
        print(f"Playing movie: {movie}")

class SoundSystem:
    def on(self):
        print("Sound system is now ON.")

    def off(self):
        print("Sound system is now OFF.")

    def set_volume(self, volume):
        print(f"Sound system volume set to {volume}")

class Lights:
    def dim(self):
        print("Lights are dimmed.")

    def on(self):
        print("Lights are now ON.")

    def off(self):
        print("Lights are now OFF.")

class HomeTheaterFacade:
    def __init__(self, tv, dvd_player, sound_system, lights):
        self.tv = tv
        self.dvd_player = dvd_player
        self.sound_system = sound_system
        self.lights = lights

    def watch_movie(self, movie):
        print("Get ready to watch a movie...")
        self.lights.dim()
        self.tv.on()
        self.dvd_player.on()
        self.sound_system.on()
        self.sound_system.set_volume(10)
        self.dvd_player.play(movie)

    def end_movie(self):
        print("Shutting movie theater down...")
        self.tv.off()
        self.dvd_player.off()
        self.sound_system.off()
        self.lights.on()

if __name__ == "__main__":

    # Create subsystem components
    tv = TV()
    dvd_player = DVDPlayer()
    sound_system = SoundSystem()
    lights = Lights()

    # Create the facade
    home_theater = HomeTheaterFacade(tv, dvd_player, sound_system, lights)

    # Watch a movie using the facade
    home_theater.watch_movie("Inception")


    # End the movie session
    home_theater.end_movie()

class Base:
  def __init__(self):
    self._a = 2

class Child(Base):
  def __init__(self):
    Base().__init__()
    self._a = 3
    print(self._a)

obj1 = Base()
print(obj1._a)

obj2 = Child()
print(obj2._a)

class Computer:
  def __init__(self, cpu, ramSize):
    self.cpu = cpu
    self.__ramSize = ramSize

  def config_Get(self):
    print("Config is", self.cpu, self.__ramSize)

  def config_Set(self, cpu, ramSize):
    self.cpu = cpu
    self.__ramSize = ramSize

class Customer(Computer):
  def __init__(self, cpu, ramSize):
    Computer().__init__(cpu, ramSize)


customer1 = Customer("i5", 16)
customer1.config_Get()
customer1.config_Set("i3", 8)
customer1.config_Get()

# prompt: class Base:

class Base:
  def __init__(self):
    pass

from abc import ABC, abstractmethod

# Abstract Product
class Vehicle(ABC):
    @abstractmethod
    def drive(self):
        pass

# Concrete Products
class Car(Vehicle):
    def drive(self):
        print("Driving a car")

class Bike(Vehicle):
    def drive(self):
        print("Riding a bike")

# Factory
class VehicleFactory:
    @staticmethod
    def create_vehicle(vehicle_type):
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "bike":
            return Bike()
        else:
            raise ValueError("Unknown vehicle type")

# Client code
if __name__ == "__main__":
    # Create a Car
    car = VehicleFactory.create_vehicle("car")
    car.drive()

    # Create a Bike
    bike = VehicleFactory.create_vehicle("bike")
    bike.drive()  # Output: Riding a bike

    # Attempting to create an unknown vehicle type will raise an error
    try:
        unknown_vehicle = VehicleFactory.create_vehicle("plane")
    except ValueError as e:
        print(e)  # Output: Unknown vehicle type



class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

@dataclass
class Student:
    name: str
    age: int

    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

from abc import ABC, abstractmethod

class Customer:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def display_info(self):
    print(f"Name: {self.name}, Age: {self.age}")

@abstractmethod
class Order(ABC):
  def confirm(self):
    pass
  def close(self):
    pass

class SpecialOrder(Order):
  def confirm(self):
    print("Confirming special order")
    print("Developer 1 will ")
  def close(self):
    print("Closing special order")

from abc import ABC, abstractmethod

class Sales(ABC):
    @abstractmethod
    def process_sale(self):
        pass


class OnlineSales(Sales):
    def process_sale(self):
        return "Processing online sale."

class InStoreSales(Sales):
    def process_sale(self):
        return "Processing in-store sale."


class SalesFactory(ABC):
    @abstractmethod
    def create_sale(self):
        pass


class OnlineSalesFactory(SalesFactory):
    def create_sale(self):
        return OnlineSales()

class InStoreSalesFactory(SalesFactory):
    def create_sale(self):
        return InStoreSales()


def sale_transaction(factory: SalesFactory):
    sale = factory.create_sale()
    print(sale.process_sale())


online_factory = OnlineSalesFactory()
sale_transaction(online_factory)  # Output: Processing online sale.


instore_factory = InStoreSalesFactory()
sale_transaction(instore_factory)  # Output: Processing in-store sale.



import pandas as pd

def read_excel_data(file_path, sheet_name=0):
    """
    Reads data from an Excel file into a pandas DataFrame.

    :param file_path: Path to the Excel file.
    :param sheet_name: Name or index of the sheet to read. Default is the first sheet.
    :return: pandas DataFrame containing the data.
    """
    # Read the Excel file
    df = pd.read_csv(file_path, sheet_name=sheet_name, engine='openpyxl')
    return df

# Example usage
if __name__ == "__main__":
    file_path = 'C:/Users/94772/Downloads/supermarket_sales.xlsx'  # Path to your Excel file
    df = read_excel_data(file_path, sheet_name='supermarket_sales')  # Replace 'Sheet1' with your sheet name or index
    print(df.head())  # Display the first few rows of the DataFrame

from google.colab import files
import pandas as pd

# Upload file
uploaded = files.upload()

# Assuming the file is named 'sales_data.xlsx'
file_name = list(uploaded.keys())[0]

# Read the Excel file
df = pd.read_excel(file_name, engine='openpyxl')

# Display the first few rows of the DataFrame
print(df.head())

from google.colab import files
import pandas as pd


uploaded = files.upload()
file_name = list(uploaded.keys())[0]
df = pd.read_csv(file_name)
print(df.head())

